# lec3-spoc
---

###通过分析[lab1_ex0](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex0.md)了解Linux应用的系统调用编写和含义。(w2l1)
 
1. file命令(根据文件内容猜测文件的格式，通常利用文件头部的数据，基于libmagic中的数据库判断类型)

	```
lab1-ex0: ELF 64-bit LSB  executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=d418c17f6483f41597ec11888ee858a67027b3b1, not stripped
	
	```

2. nm(从elf文件中获取符号信息，如所有函数（非static）所在的地址等，在逆向工程时是很好的分析手段)

	```
0000000000000002 a AF_INET000000000060105c B __bss_start000000000060105c 0000000000000001 b completed.69720000000000601028 D __data_start0000000000601028 W data_start0000000000400430 t deregister_tm_clones00000000004004a0 t __do_global_dtors_aux0000000000600e18 t __do_global_dtors_aux_fini_array_entry0000000000601030 D __dso_handle0000000000600e28 d _DYNAMIC000000000060105c D _edata0000000000601060 B _end0000000000400564 T _fini00000000004004c0 t frame_dummy0000000000600e10 t __frame_dummy_init_array_entry0000000000400670 r __FRAME_END__0000000000601000 d _GLOBAL_OFFSET_TABLE_                 w __gmon_start__0000000000601038 d hello00000000004003a8 T _init0000000000600e18 t __init_array_end0000000000600e10 t __init_array_start0000000000400570 0000000000000004 R _IO_stdin_used0000000000000006 a IPPROTO_TCP                 w _ITM_deregisterTMCloneTable                 w _ITM_registerTMCloneTable0000000000600e20 d __JCR_END__0000000000600e20 d __JCR_LIST__                 w _Jv_RegisterClasses0000000000400560 0000000000000002 T __libc_csu_fini00000000004004f0 0000000000000065 T __libc_csu_init                 U __libc_start_main@@GLIBC_2.2.50000000000601045 D main0000000000000001 a MAP_SHARED0000000000000001 a PROT_READ0000000000400460 t register_tm_clones0000000000000002 a SEEK_END0000000000000001 a SOCK_STREAM0000000000400400 T _start0000000000000001 a STDOUT0000000000000006 a SYS_close000000000000003f a SYS_dup2000000000000000b a SYS_execve0000000000000001 a SYS_exit0000000000000002 a SYS_fork0000000000000013 a SYS_lseek000000000000005a a SYS_mmap000000000000005b a SYS_munmap0000000000000005 a SYS_open0000000000000066 a SYS_socketcall0000000000000005 a SYS_socketcall_accept0000000000000002 a SYS_socketcall_bind0000000000000004 a SYS_socketcall_listen0000000000000001 a SYS_socketcall_socket0000000000000004 a SYS_write0000000000601060 D __TMC_END__	```	
	
	
3. objdump(从elf或者二进制机器码文件中反编译出汇编指令)
阅读`lab1_ex0.s`

	```
	.include "defines.h"
	.data
	hello:
		.string "hello world\n"
	
	.globl	main
	main:
		movl	$SYS_write,%eax
		movl	$STDOUT,%ebx
		movl	$hello,%ecx
		movl	$12,%edx
		int	$0x80
	
		ret	
	```
	
编译出来的文件见[lab1_ex0](lab1_ex0.txt)

可见其作用为通过调用SYS_write，把"hello world\n"输出至屏幕。
使用时须根据功能找到指定系统调用号，然后选择输出目的地址，并将需要输出的字符串以及长度规定，然后调用`int 0x80`指令进行系统调用

系统调用的具体含义：
	系统调用是应用程序使用内核提供的一些功能的接口。
 
###通过调试[lab1_ex1](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex1.md)了解Linux应用的系统调用执行过程。(w2l1)
