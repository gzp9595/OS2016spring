# lec6 SPOC思考题


NOTICE
- 有"w3l2"标记的题是助教要提交到学堂在线上的。
- 有"w3l2"和"spoc"标记的题是要求拿清华学分的同学要在实体课上完成，并按时提交到学生对应的git repo上。
- 有"hard"标记的题有一定难度，鼓励实现。
- 有"easy"标记的题很容易实现，鼓励实现。
- 有"midd"标记的题是一般水平，鼓励实现。

## 与视频相关思考题

### 6.1	非连续内存分配的需求背景
为什么要设计非连续内存分配机制？
 
> 因为连续分配时会产生外碎片和内碎片，而且此时内存分配的动态修改困难，从而导致内存利用率较低。相反，采用非连续分配机制，通过允许一个程序使用非连续的物理地址空间，允许共享代码与数据和支持动态加载和动态链接，可以提高内存利用效率和管理灵活性。

非连续内存分配中内存分块大小有哪些可能的选择？大小与大小是否可变

>可以选择段式存储管理（内存分块较大）和页式存储管理（内存分块较小）。段式存储管理中分块大小可变，而页式中不可变。

为什么在大块时要设计大小可变，而在小块时要设计成固定大小？小块时的固定大小可以提供多种选择吗？

>大块时设计大小可变可以达到更细粒度和灵活的分离与共享的目的。而小块的设计成固定大小可以更好地进行内存利用和优化转移到后备存储方面。小块时的固定大小可以有多种选择。

### 6.2	段式存储管理
什么是段、段基址和段内偏移？
 
 >段表示访问方式和存储数据等属性相同的一段地址空间。段基址指某个特定的段号对应的某个段的物理内存的起始地址。段内偏移指某个地址在其对应的段的物理内存中的偏移量。
 
段式存储管理机制的地址转换流程是什么？为什么在段式存储管理中，各段的存储位置可以不连续？这种做法有什么好处和麻烦？

>某个地址先取出段号，在段表中找到段的基址和段长度，然后MMU进行相应的安全性检查，检查到这个地址是合法地址后，由段基址拼接上原地址上的偏移部分就是这个逻辑地址对应的物理地址。好处是可以保护各个段不同的内存空间，允许各个进程使用它自己的逻辑地址空间。坏处是可能会产生外碎片。

### 6.3	页式存储管理
什么是页（page）、帧（frame）、页表（page table）、存储管理单元（MMU）、快表（TLB, Translation Lookaside Buffer）和高速缓存（cache）？

>页是把逻辑地址空间划分为相同大小的基本分配单位。帧是把物理地址空间划分为大小相同的基本分配单位。页表保存了逻辑地址到物理地址之间的映射关系。存储管理单元是CPU中用来管理虚拟存储器、物理存储器的控制线路，同时也是扶着虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权，多用户多进程操作系统。

页式存储管理机制的地址转换流程是什么？为什么在页式存储管理中，各段的存储位置可以不连续？这种做法有什么好处和麻烦？

>对于某个逻辑地址，首先根据它的逻辑页号访问内存中的页表，找到其对应的物理页号，然后拼接物理页号和其逻辑地址中的页内偏移就得到了其物理地址。好处是可以使不同的进程独自用其逻辑地址空间，麻烦是每次访问一个地址需要访问内存两次。

### 6.4	页表概述
每个页表项有些什么内容？有哪些标志位？它们起什么作用？

>页表项包括帧号和页表项标志位。存在位，修改位，引用位。存在位表示这个帧在内存中是否存在，修改位表示这帧在内存中是否被修改过（方便以后被写回到外存当中），引用位表示这个帧中的数据是否曾经被访问过。

 页表大小受哪些因素影响？

>页大小、地址空间大小、进程数目

### 6.5	快表和多级页表
 1. 快表（TLB）与高速缓存（cache）有什么不同？

 > 它们本质上是一样的，但是它们被用在的场合不一样。TLB主要用于缓存近期CPU访问过的页表项，而cache主要用于存储最近被CPU访问过的内存中的数据。
 
 1. 为什么快表中查找物理地址的速度非常快？它是如何实现的？为什么它的的容量很小？

 > 因为它本身访问速度就很快，从而避免了访问内存中的页表，从而大大提升了查找物理地址的时间。使用关联存储实现。因为成本很高，所以只能做成容量比较小的样子。
 
 1. 什么是多级页表？多级页表中的地址转换流程是什么？多组页面有什么好处和麻烦？

 > 多级页表就是通过间接引用将页号分成k级，建立起页表树，从而减少每级页表的长度的做法。对于某个逻辑地址，把地址前面的索引段按照页表级数分开，依次访问不同级的页表，直到最后得到帧号，然后再加上原逻辑地址中的偏移量就可以得到对应的物理地址。好处是可以减少页表的长度，坏处是增加了访问内存的次数。

### 6.6	反置页表
 1. 页寄存器机制的地址转换流程是什么？
 	
 >  首先对逻辑地址进行Hash变换，然后在块表中查找对应的页表项，有冲突时遍历冲突项链表，查找失败时会产生异常。
  
 1. 反置页表机制的地址转换流程是什么？
 
 >  根据进程标识和页号进行Hash变换，然后与页表项中内容匹配看是否配对，若不配对再看下一项，直到最后配对，最后就可以得到其物理地址。
 
 1. 反置页表项有些什么内容？

 >  PID、逻辑页号、标志位

### 6.7	段页式存储管理
 1. 段页式存储管理机制的地址转换流程是什么？这种做法有什么好处和麻烦？

 >  对于某个逻辑地址，对于其前面段号的部分在其进程对应的段表中找到其段表项，在段表项中找到对于的页表地址，然后对于原逻辑地址中页号部分找到页表项，在页表项中找到帧号，最后加上逻辑地址中的偏移量就可以得到物理地址。
 
 1. 如何实现基于段式存储管理的内存共享？

 >  通过指向相同的页表基址，实现进程间的段共享。
 
 1. 如何实现基于页式存储管理的内存共享？
 
 >  让不同的进程利用相同的页表。

## 个人思考题
---

（1） (w3l2) 请简要分析64bit CPU体系结构下的分页机制是如何实现的
```
  + 采分点：说明64bit CPU架构的分页机制的大致特点和页表执行过程
  - 答案没有涉及如下3点；（0分）
  - 正确描述了64bit CPU支持的物理内存大小限制（1分）
  - 正确描述了64bit CPU下的多级页表的级数和多级页表的结构或反置页表的结构（2分）
  - 除上述两点外，进一步描述了在多级页表或反置页表下的虚拟地址-->物理地址的映射过程（3分）
 ```
- [x]  

>  

## 小组思考题
---

（1）(spoc) 某系统使用请求分页存储管理，若页在内存中，满足一个内存请求需要150ns (10^-9s)。若缺页率是10%，为使有效访问时间达到0.5us(10^-6s),求不在内存的页面的平均访问时间。请给出计算步骤。 

- [x]  

> 500=0.9\*150+0.1\*x

（2）(spoc) 有一台假想的计算机，页大小（page size）为32 Bytes，支持32KB的虚拟地址空间（virtual address space）,有4KB的物理内存空间（physical memory），采用二级页表，一个页目录项（page directory entry ，PDE）大小为1 Byte,一个页表项（page-table entries
PTEs）大小为1 Byte，1个页目录表大小为32 Bytes，1个页表大小为32 Bytes。页目录基址寄存器（page directory base register，PDBR）保存了页目录表的物理地址（按页对齐）。

PTE格式（8 bit） :
```
  VALID | PFN6 ... PFN0
```
PDE格式（8 bit） :
```
  VALID | PT6 ... PT0
```
其
```
VALID==1表示，表示映射存在；VALID==0表示，表示映射不存在。
PFN6..0:页帧号
PT6..0:页表的物理基址>>5
```
在[物理内存模拟数据文件](./03-2-spoc-testdata.md)中，给出了4KB物理内存空间的值，请回答下列虚地址是否有合法对应的物理内存，请给出对应的pde index, pde contents, pte index, pte contents。
```
1) Virtual Address 6c74
   Virtual Address 6b22
2) Virtual Address 03df
   Virtual Address 69dc
3) Virtual Address 317a
   Virtual Address 4546
4) Virtual Address 2c03
   Virtual Address 7fd7
5) Virtual Address 390e
   Virtual Address 748b
```

比如答案可以如下表示： (注意：下面的结果是错的，你需要关注的是如何表示)
```
Virtual Address 7570:
  --> pde index:0x1d  pde contents:(valid 1, pfn 0x33)
    --> pte index:0xb  pte contents:(valid 0, pfn 0x7f)
      --> Fault (page table entry not valid)
      
Virtual Address 21e1:
  --> pde index:0x8  pde contents:(valid 0, pfn 0x7f)
      --> Fault (page directory entry not valid)

Virtual Address 7268:
  --> pde index:0x1c  pde contents:(valid 1, pfn 0x5e)
    --> pte index:0x13  pte contents:(valid 1, pfn 0x65)
      --> Translates to Physical Address 0xca8 --> Value: 16
```


> 第二题第5组

```
Virtual Address 390e:
  --> pde index:0xe  pde contents:(valid 0, pfn 0x7f)
       --> Fault (page directory entry not valid)
       
```

```
Virtual Address 748b:
	--> pde index:0x1d pde contents:(valid 1, pfn 0x00)
		--> pte index:0x04 pte contents:(valid 0, pfn 0x7f)
			--> Fault (page table entry not valid)
```


（3）请基于你对原理课二级页表的理解，并参考Lab2建页表的过程，设计一个应用程序（可基于python、ruby、C、C++、LISP、JavaScript等）可模拟实现(2)题中描述的抽象OS，可正确完成二级页表转换。


（4）假设你有一台支持[反置页表](http://en.wikipedia.org/wiki/Page_table#Inverted_page_table)的机器，请问你如何设计操作系统支持这种类型计算机？请给出设计方案。

 (5)[X86的页面结构](http://os.cs.tsinghua.edu.cn/oscourse/OS2015/lecture06#head-1f58ea81c046bd27b196ea2c366d0a2063b304ab)
--- 

## 扩展思考题

阅读64bit IBM Powerpc CPU架构是如何实现[反置页表](http://en.wikipedia.org/wiki/Page_table#Inverted_page_table)，给出分析报告。

--- 


## interactive　understand VM

- [Virtual Memory with 256 Bytes of RAM](http://blog.robertelder.org/virtual-memory-with-256-bytes-of-ram/)




#lec6

